<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Multi-Level Paddle Ball Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');

    body {
      margin: 0;
      font-family: 'Orbitron', monospace;
      user-select: none;
      -webkit-user-select: none;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      padding: 10px 0;
      transition: background 1s ease;
    }

    h1 {
      margin: 10px 0 0;
      font-weight: 700;
      text-align: center;
      text-shadow: 0 0 8px #00ffe0;
    }

    canvas {
      border: 3px solid #00ffe0;
      border-radius: 12px;
      box-shadow: 0 0 15px #00ffe0;
      margin-top: 15px;
      touch-action: none;
      display: block;
      max-width: 100vw;
      max-height: 70vh;
      background: transparent;
      transition: background 1s ease;
    }

    #infoBar {
      margin-top: 10px;
      width: 700px;
      max-width: 95vw;
      display: flex;
      justify-content: space-between;
      font-size: 20px;
      text-shadow: 0 0 6px #00ffe0;
      color: #00ffe0;
    }

    #restartBtn {
      margin-top: 12px;
      padding: 8px 20px;
      background: #00ffe0;
      border: none;
      border-radius: 6px;
      color: #111;
      font-weight: 700;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 0 10px #00ffe0;
      transition: background-color 0.3s ease;
    }
    #restartBtn:hover {
      background: #0ff;
    }

    #developerCredit {
      margin-top: 20px;
      font-size: 16px;
      color: #00ffe0cc;
      font-weight: 600;
      user-select: none;
      text-align: center;
      text-shadow: 0 0 4px #00ffe088;
    }

    #levelDisplay {
      margin-top: 10px;
      font-size: 22px;
      font-weight: 700;
      color: #00ffe0;
      text-shadow: 0 0 8px #00ffe0;
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      #infoBar {
        font-size: 16px;
        width: 95vw;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
      }
      #developerCredit {
        font-size: 14px;
      }
      canvas {
        max-height: 60vh;
      }
      #levelDisplay {
        font-size: 18px;
      }
    }
  </style>
</head>
<body>
  <h1>Multi-Level Paddle Ball Game</h1>

  <canvas id="gameCanvas" width="700" height="500"></canvas>

  <div id="infoBar">
    <div>Level: <span id="levelNumber">1</span></div>
    <div>Score: <span id="score">0</span></div>
    <div>High Score: <span id="highscore">0</span></div>
    <div>Lives: <span id="lives">3</span> ❤️</div>
  </div>

  <button id="restartBtn">Restart Game</button>

  <div id="developerCredit">Developed by Manas Rao</div>

  <!-- Sounds -->
  <audio id="bounceSound" src="https://actions.google.com/sounds/v1/sports/ball_bounce.ogg" preload="auto"></audio>
  <audio id="brickSound1" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>
  <audio id="brickSound2" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>
  <audio id="brickSound3" src="https://actions.google.com/sounds/v1/cartoon/clang.ogg" preload="auto"></audio>
  <audio id="gameOverSound" src="https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg" preload="auto"></audio>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const highScoreEl = document.getElementById("highscore");
  const livesEl = document.getElementById("lives");
  const levelEl = document.getElementById("levelNumber");
  const restartBtn = document.getElementById("restartBtn");

  const bounceSound = document.getElementById("bounceSound");
  const brickSounds = [
    document.getElementById("brickSound1"),
    document.getElementById("brickSound2"),
    document.getElementById("brickSound3")
  ];
  const gameOverSound = document.getElementById("gameOverSound");

  // Paddle properties
  const paddle = {
    width: 120,
    height: 15,
    x: canvas.width / 2 - 60,
    y: canvas.height - 40,
    speed: 40
  };

  // Ball properties - start slower
  let ball = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: 10,
    baseSpeed: 3,
    speed: 3,
    dx: 3,
    dy: -3,
    trail: []
  };

  // Game state variables
  let score = 0;
  let highScore = localStorage.getItem("highScore") || 0;
  let lives = 3;
  let gameOver = false;
  let currentLevel = 0;

  // Levels array with unique settings
  const levels = [
    {
      name: "Neon Grid",
      background: "linear-gradient(135deg, #0f2027, #203a43, #2c5364)",
      brickRows: 5,
      brickCols: 8,
      brickColor: "#00ffe0",
      brickShadow: "#00ffe0",
      brickLayout: null, // default full bricks
      ballSpeed: 3,
      brickSoundIndex: 0
    },
    {
      name: "Firestorm",
      background: "radial-gradient(circle, #ff4e50, #f9d423)",
      brickRows: 4,
      brickCols: 10,
      brickColor: "#ff4e50",
      brickShadow: "#ff1e00",
      brickLayout: function(rows, cols) {
        // Checkerboard pattern of bricks
        let layout = [];
        for(let r=0; r<rows; r++) {
          layout[r] = [];
          for(let c=0; c<cols; c++) {
            layout[r][c] = (r + c) % 2 === 0 ? 1 : 0;
          }
        }
        return layout;
      },
      ballSpeed: 3.5,
      brickSoundIndex: 1
    },
    {
      name: "Ocean Breeze",
      background: "linear-gradient(135deg, #00c6ff, #0072ff)",
      brickRows: 6,
      brickCols: 7,
      brickColor: "#0072ff",
      brickShadow: "#00c6ff",
      brickLayout: function(rows, cols) {
        // Pyramid shape bricks
        let layout = [];
        for(let r=0; r<rows; r++) {
          layout[r] = [];
          for(let c=0; c<cols; c++) {
            layout[r][c] = (c >= r && c < cols - r) ? 1 : 0;
          }
        }
        return layout;
      },
      ballSpeed: 4,
      brickSoundIndex: 2
    },
    // Add more levels here up to 50 with different patterns/colors/backgrounds
  ];

  // Brick properties (will be updated per level)
  let bricks = [];
  let brickWidth, brickHeight, brickPadding, brickOffsetTop, brickOffsetLeft;

  // Initialize bricks based on current level
  function initBricks() {
    const lvl = levels[currentLevel];
    brickPadding = 10;
    brickOffsetTop = 50;
    brickOffsetLeft = 30;

    // Calculate brick width based on canvas width and columns
    brickWidth = (canvas.width - brickOffsetLeft * 2 - (lvl.brickCols - 1) * brickPadding) / lvl.brickCols;
    brickHeight = 20;

    bricks = [];
    let layout = lvl.brickLayout;
    if (typeof layout === "function") {
      layout = layout(lvl.brickRows, lvl.brickCols);
    }
    for(let r = 0; r < lvl.brickRows; r++) {
      bricks[r] = [];
      for(let c = 0; c < lvl.brickCols; c++) {
        // If layout is defined, use that, else default to all bricks visible
        let status = (layout && layout[r] && layout[r][c] === 1) ? 1 : 0;
        bricks[r][c] = { x: 0, y: 0, status: status };
      }
    }
  }

  // Draw bricks with level-specific colors and shadows
  function drawBricks() {
    const lvl = levels[currentLevel];
    for(let r=0; r < bricks.length; r++) {
      for(let c=0; c < bricks[r].length; c++) {
        const b = bricks[r][c];
        if(b.status === 1) {
          const brickX = c*(brickWidth + brickPadding) + brickOffsetLeft;
          const brickY = r*(brickHeight + brickPadding) + brickOffsetTop;
          b.x = brickX;
          b.y = brickY;
          ctx.fillStyle = lvl.brickColor;
          ctx.shadowColor = lvl.brickShadow;
          ctx.shadowBlur = 15;
          ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
          ctx.shadowBlur = 0;
        }
      }
    }
  }

  // Draw paddle
  function drawPaddle() {
    ctx.fillStyle = "#00ffe0";
    ctx.shadowColor = '#00ffe0';
    ctx.shadowBlur = 15;
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    ctx.shadowBlur = 0;
  }

  // Draw ball with trail
  function drawBall() {
    ball.trail.push({x: ball.x, y: ball.y});
    if(ball.trail.length > 15) ball.trail.shift();

    for(let i = 0; i < ball.trail.length; i++) {
      const pos = ball.trail[i];
      const alpha = i / ball.trail.length / 2;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, ball.radius, 0, Math.PI*2);
      ctx.fillStyle = `rgba(0, 255, 224, ${alpha})`;
      ctx.fill();
      ctx.closePath();
    }

    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
    ctx.fillStyle = '#00ffe0';
    ctx.shadowColor = '#00ffe0';
    ctx.shadowBlur = 20;
    ctx.fill();
    ctx.closePath();
    ctx.shadowBlur = 0;
  }

  // Move ball
  function moveBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;
  }

  // Detect collisions
  function detectCollisions() {
    // Walls
    if(ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
      ball.dx = -ball.dx;
      playSound(bounceSound);
    }
    if(ball.y - ball.radius < 0) {
      ball.dy = -ball.dy;
      playSound(bounceSound);
    }

    // Paddle collision
    if(ball.y + ball.radius >= paddle.y &&
       ball.x >= paddle.x &&
       ball.x <= paddle.x + paddle.width) {
      ball.dy = -Math.abs(ball.dy);
      playSound(bounceSound);

      score++;
      updateScore();

      // Increase speed every 5 points capped at 10
      if(score > 0 && score % 5 === 0) {
        increaseSpeed();
      }
    }

    // Bricks collision
    let bricksRemaining = 0;
    const lvl = levels[currentLevel];
    for(let r=0; r<bricks.length; r++) {
      for(let c=0; c<bricks[r].length; c++) {
        const b = bricks[r][c];
        if(b.status === 1) {
          bricksRemaining++;
          if(ball.x > b.x && ball.x < b.x + brickWidth &&
            ball.y - ball.radius < b.y + brickHeight && 
            ball.y + ball.radius > b.y) {
            ball.dy = -ball.dy;
            b.status = 0;
            score += 2;
            updateScore();
            playSound(brickSounds[lvl.brickSoundIndex]);
          }
        }
      }
    }

    // Check if all bricks cleared, go next level or win
    if(bricksRemaining === 0) {
      nextLevel();
    }

    // Ball falls below paddle
    if(ball.y - ball.radius > canvas.height) {
      lives--;
      updateLives();
      if(lives <= 0) {
        endGame();
      } else {
        resetBallPaddle();
      }
    }
  }

  function playSound(sound) {
    if(!sound) return;
    sound.currentTime = 0;
    sound.play();
  }

  // Increase ball speed gradually
  function increaseSpeed() {
    const maxSpeed = 10;
    if(Math.abs(ball.dx) < maxSpeed) {
      ball.dx *= 1.1;
      ball.dy *= 1.1;
    }
  }

  // Update score display
  function updateScore() {
    scoreEl.textContent = score;
    if(score > highScore) {
      highScore = score;
      highScoreEl.textContent = highScore;
      localStorage.setItem("highScore", highScore);
    }
  }

  // Update lives display
  function updateLives() {
    livesEl.textContent = lives;
  }

  // Reset ball and paddle position
  function resetBallPaddle() {
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
    const baseSpeed = levels[currentLevel].ballSpeed || 3;
    ball.speed = baseSpeed;
    ball.dx = baseSpeed * (Math.random() > 0.5 ? 1 : -1);
    ball.dy = -baseSpeed;
    paddle.x = canvas.width / 2 - paddle.width / 2;
  }

  // Clamp paddle inside canvas
  function clampPaddle() {
    if(paddle.x < 0) paddle.x = 0;
    if(paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
  }

  // Draw all game elements
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBricks();
    drawPaddle();
    drawBall();
  }

  // Game loop
  function update() {
    if(gameOver) return;
    moveBall();
    detectCollisions();
    draw();
    requestAnimationFrame(update);
  }

  // Keyboard controls
  document.addEventListener("keydown", (e) => {
    if(e.key === "ArrowLeft") {
      paddle.x -= paddle.speed;
      clampPaddle();
    }
    if(e.key === "ArrowRight") {
      paddle.x += paddle.speed;
      clampPaddle();
    }
  });

  // Mouse control
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    paddle.x = e.clientX - rect.left - paddle.width / 2;
    clampPaddle();
  });

  // Touch control
  let isDragging = false;
  canvas.addEventListener("touchstart", (e) => {
    isDragging = true;
    movePaddleTouch(e);
  });
  canvas.addEventListener("touchmove", (e) => {
    if(isDragging) movePaddleTouch(e);
  });
  canvas.addEventListener("touchend", () => {
    isDragging = false;
  });
  function movePaddleTouch(e) {
    const rect = canvas.getBoundingClientRect();
    paddle.x = e.touches[0].clientX - rect.left - paddle.width / 2;
    clampPaddle();
  }

  // Next level logic
  function nextLevel() {
    currentLevel++;
    if(currentLevel >= levels.length) {
      winGame();
      return;
    }
    lives++; // Reward 1 life per level
    updateLives();
    resetBallPaddle();
    initBricks();
    updateUI();
  }

  // Update UI elements and background for current level
  function updateUI() {
    const lvl = levels[currentLevel];
    levelEl.textContent = currentLevel + 1;
    document.body.style.background = lvl.background;
    canvas.style.background = lvl.background;
  }

  // End game - lose
  function endGame() {
    gameOver = true;
    playSound(gameOverSound);
    alert("Game Over! Your score: " + score);
    restartBtn.style.display = "inline-block";
  }

  // Win game
  function winGame() {
    gameOver = true;
    alert("🎉 Congratulations! You cleared all levels! Your final score: " + score);
    restartBtn.style.display = "inline-block";
  }

  // Restart game
  restartBtn.addEventListener("click", () => {
    resetGame();
  });

  function resetGame() {
    score = 0;
    lives = 3;
    currentLevel = 0;
    gameOver = false;
    updateScore();
    updateLives();
    updateUI();
    resetBallPaddle();
    initBricks();
    restartBtn.style.display = "none";
    update();
  }

  // Initialize first level on load
  updateUI();
  initBricks();
  resetBallPaddle();
  updateScore();
  updateLives();
  restartBtn.style.display = "none";

  update();
</script>

</body>
</html>
